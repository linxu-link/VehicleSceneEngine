åœ¨æ™ºèƒ½æ±½è½¦å¿«é€Ÿå‘å±•çš„ä»Šå¤©ï¼Œè½¦è½½ç³»ç»Ÿæ—©å·²ä¸å†æ˜¯ç®€å•çš„å¨±ä¹æˆ–å¯¼èˆªå·¥å…·ï¼Œè€Œæ˜¯é›†æˆäº†æ„ŸçŸ¥ã€å†³ç­–ä¸æœåŠ¡äºä¸€ä½“çš„æ™ºèƒ½äº¤äº’å¹³å°ã€‚å…¶ä¸­ï¼Œâ€œ**åœºæ™¯å¼•æ“**â€ï¼ˆä¸€äº›è½¦å‹ä¸Šä¹Ÿç§°â€œ**æ™ºèƒ½åœºæ™¯**â€ï¼‰ä½œä¸ºæå‡ç”¨æˆ·ä½“éªŒã€å®ç°ä¸ªæ€§åŒ–æœåŠ¡çš„æ ¸å¿ƒèƒ½åŠ›ï¼Œæ­£è¢«è¶Šæ¥è¶Šå¤šçš„ä¸­é«˜ç«¯æ™ºèƒ½æ±½è½¦æ‰€é‡‡ç”¨ã€‚

æœ¬æ–‡å°†ç»“åˆç¬”è€…åœ¨å®é™…é¡¹ç›®ä¸­çš„å·¥ä½œç»éªŒï¼Œæ·±å…¥åˆ†æè½¦è½½â€œåœºæ™¯å¼•æ“â€çš„æ ¸å¿ƒéœ€æ±‚ï¼Œå¹¶æ¢è®¨å…¶é«˜æ•ˆè®¾è®¡æ–¹æ³•ã€‚å‡ºäºä¼ä¸šä¿å¯†è¦æ±‚ï¼Œæ–‡ä¸­æ‰€å‘ˆç°çš„åœºæ™¯å¼•æ“ä¸ºä¸€ä¸ªç®€åŒ–ç‰ˆçš„åŸå‹ï¼Œä»…ç”¨äºæŠ€æœ¯åŸç†çš„é˜è¿°ä¸äº¤æµã€‚

> æœ¬æ–‡æºç è·¯å¾„ï¼šhttps://github.com/linxu-link/VehicleSceneEngine




## ä¸€ã€ä»€ä¹ˆæ˜¯â€œåœºæ™¯å¼•æ“â€ï¼Ÿ

ç®€å•æ¥è¯´ï¼Œåœºæ™¯å¼•æ“æ˜¯ä¸€ä¸ª**åŸºäºå¤šç»´ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„è‡ªåŠ¨åŒ–å†³ç­–ä¸æ‰§è¡Œæ¡†æ¶**ã€‚å®ƒèƒ½å¤Ÿå®æ—¶é‡‡é›†è½¦è¾†çŠ¶æ€ã€ç”¨æˆ·è¡Œä¸ºã€ç¯å¢ƒä¿¡æ¯ç­‰æ•°æ®ï¼Œåœ¨æ»¡è¶³é¢„è®¾æ¡ä»¶æ—¶ï¼Œè‡ªåŠ¨è§¦å‘ä¸€ç³»åˆ—æœåŠ¡ç»„åˆï¼ˆå¦‚è°ƒèŠ‚ç©ºè°ƒã€åˆ‡æ¢åª’ä½“ã€å‘é€é€šçŸ¥ç­‰ï¼‰ã€‚

è™½ç„¶åº”ç”¨åœºæ™¯ä¸åŒï¼Œä½†å…¶åº•å±‚é€»è¾‘ä¸ Android ä¸­çš„â€œè§„åˆ™å¼•æ“â€â€œè‡ªåŠ¨åŒ–ä»»åŠ¡â€æˆ–â€œæƒ…å¢ƒæ„ŸçŸ¥åŠŸèƒ½â€ï¼ˆå¦‚ Do Not Disturbã€è‡ªé€‚åº”äº®åº¦ï¼‰éå¸¸ç›¸ä¼¼ã€‚

1.  ### æ ¸å¿ƒéœ€æ±‚åˆ†æä¸€ä¸ªé«˜æ•ˆçš„åœºæ™¯å¼•æ“ï¼Œé¦–å…ˆä¾èµ–äºå¯¹**å¤šæºä¸Šä¸‹æ–‡**çš„å®æ—¶é‡‡é›†ä¸èåˆã€‚è¿™äº›ä¸Šä¸‹æ–‡å¯å½’çº³ä¸ºä»¥ä¸‹å››ç±»ï¼š

-   **è®¾å¤‡/è½¦è¾†çŠ¶æ€** å¦‚è½¦é€Ÿã€æ¡£ä½ã€ç”µé‡ã€è½¦é—¨/è½¦çª—çŠ¶æ€ã€ADASï¼ˆé«˜çº§é©¾é©¶è¾…åŠ©ç³»ç»Ÿï¼‰æ˜¯å¦å¯ç”¨ç­‰ã€‚
-   **ç”¨æˆ·çŠ¶æ€** é€šè¿‡ FaceID æˆ–è´¦å·è¯†åˆ«é©¾é©¶å‘˜èº«ä»½ï¼Œç»“åˆ DMSï¼ˆé©¾é©¶å‘˜ç›‘æ§ç³»ç»Ÿï¼‰åˆ¤æ–­ç–²åŠ³åº¦ã€æ³¨æ„åŠ›ç­‰ã€‚
-   **ç¯å¢ƒä¿¡æ¯** åŒ…æ‹¬ GPS ä½ç½®ã€å½“å‰æ—¶é—´ã€å¤©æ°”ã€è·¯å†µã€å®¤å†…å¤–æ¸©åº¦ç­‰ã€‚
-   **å¤–è®¾ä¸åº”ç”¨çŠ¶æ€** æ‰‹æœºæ˜¯å¦è¿æ¥ã€è“ç‰™è€³æœºæ˜¯å¦é…å¯¹ã€åº§æ¤…ä½ç½®ã€ç©ºè°ƒè®¾ç½®ã€å½“å‰æ’­æ”¾çš„åª’ä½“ç­‰ã€‚

è¿™äº›æ•°æ®å…±åŒæ„æˆäº†â€œä¸Šä¸‹æ–‡æ„ŸçŸ¥â€çš„åŸºç¡€ï¼Œä¹Ÿæ˜¯è§¦å‘æ™ºèƒ½åœºæ™¯çš„å‰æã€‚




### 2. åœºæ™¯å®šä¹‰ä¸ç®¡ç†

ä»…ä»…èƒ½æ„ŸçŸ¥è¿˜ä¸å¤Ÿï¼Œç³»ç»Ÿè¿˜éœ€æ”¯æŒ**çµæ´»çš„åœºæ™¯ç¼–æ’**ä¸**å¯é çš„æ‰§è¡Œæœºåˆ¶**ï¼š

1. å¯è§†åŒ–è§„åˆ™ç¼–æ’

-   æ”¯æŒâ€œå¦‚æœâ€¦é‚£ä¹ˆâ€¦â€ï¼ˆIf-Thenï¼‰é€»è¾‘ï¼Œå…è®¸ OEM å‚å•†æˆ–ç»ˆç«¯ç”¨æˆ·è‡ªå®šä¹‰åœºæ™¯ã€‚

> -   ç¤ºä¾‹ï¼š`IF è½¦é€Ÿ > 60km/h AND æ—¶é—´åœ¨ 22:00â€“6:00 â†’ è‡ªåŠ¨è°ƒæš—å±å¹• + å…³é—­é€šçŸ¥éŸ³`

-   æ”¯æŒå¤æ‚æ¡ä»¶ç»„åˆï¼ˆAND/OR/NOTï¼‰ã€æ—¶é—´çª—å£é™åˆ¶ã€çŠ¶æ€æŒç»­åˆ¤æ–­ï¼ˆå¦‚â€œè¿ç»­5åˆ†é’Ÿæœªæ“ä½œâ€ï¼‰ã€‚

2. åœºæ™¯ä¼˜å…ˆçº§ä¸å†²çªå¤„ç†

-   å½“å¤šä¸ªåœºæ™¯åŒæ—¶æ»¡è¶³æ—¶ï¼Œéœ€æŒ‰**å®‰å…¨ç­‰çº§**æˆ–**ç”¨æˆ·åå¥½**è¿›è¡Œæ’åºï¼Œé¿å…æŒ‡ä»¤å†²çªã€‚
-   ä¾‹å¦‚ï¼šâ€œé©¾é©¶æ¨¡å¼â€åº”ä¼˜å…ˆäºâ€œè§‚å½±æ¨¡å¼â€ã€‚

3. é¢„ç½® + è‡ªå­¦ä¹ åŒæ¨¡å¼

-   **å‡ºå‚é¢„ç½®é«˜é¢‘åœºæ™¯**ï¼šå¦‚â€œå›å®¶æ¨¡å¼â€â€œéœ²è¥æ¨¡å¼â€â€œå„¿ç«¥æ¨¡å¼â€ï¼Œé™ä½ç”¨æˆ·ä½¿ç”¨é—¨æ§›ã€‚
-   **è¡Œä¸ºå­¦ä¹ ä¸æ¨è**ï¼šéšç€å¤§æ¨¡å‹ä¸Šè½¦ï¼Œé€šè¿‡ AI å¤§æ¨¡å‹åˆ†æç”¨æˆ·ä¹ æƒ¯ï¼ˆå¦‚æ¯å¤© 18:00 è¿æ¥è“ç‰™ã€å‘¨äº”å¼€å¯åº§æ¤…åŠ çƒ­ï¼‰ï¼Œè‡ªåŠ¨ç”Ÿæˆå»ºè®®åœºæ™¯ï¼Œä¹Ÿå˜å¾—éå¸¸å¸¸è§ã€‚




### 3. æ ¸å¿ƒè®¾è®¡æ€æƒ³ï¼šäº‹ä»¶é©±åŠ¨ä¸è§„åˆ™åŒ¹é…

åœºæ™¯å¼•æ“çš„æœ¬è´¨ï¼Œæ˜¯ä¸€ä¸ª**è½»é‡çº§è§„åˆ™å¼•æ“**ï¼Œå…¶æ ¸å¿ƒæµç¨‹å¦‚ä¸‹ï¼š

1.  **äº‹ä»¶é©±åŠ¨**ï¼šä»»ä½•ä¸Šä¸‹æ–‡ä¿¡å·çš„å˜åŒ–ï¼ˆå¦‚è½¦é€Ÿæ›´æ–°ã€æ—¶é—´è·³è½¬ï¼‰éƒ½ä½œä¸ºäº‹ä»¶è¾“å…¥ã€‚
1.  **è§„åˆ™åŒ¹é…**ï¼šæ¯ä¸ªåœºæ™¯å¯¹åº”ä¸€ç»„æ¡ä»¶è§„åˆ™ï¼Œå½“æ‰€æœ‰æ¡ä»¶æ»¡è¶³æ—¶ï¼Œè¯¥åœºæ™¯è¢«æ¿€æ´»ã€‚
1.  **è§£è€¦ä¸å¯é…ç½®**ï¼šè§„åˆ™åº”ä»¥ JSON/YAML æˆ–æ•°æ®åº“å½¢å¼å¤–éƒ¨åŒ–ï¼Œä¾¿äº OTA æ›´æ–°æˆ– A/B æµ‹è¯•ã€‚
1.  **é«˜æ•ˆè¯„ä¼°**ï¼šé¿å…æ¯æ¬¡å…¨é‡éå†æ‰€æœ‰è§„åˆ™ï¼Œé‡‡ç”¨å¢é‡æ›´æ–°ã€ç¼“å­˜æœºåˆ¶æˆ–åå‘ç´¢å¼•ä¼˜åŒ–æ€§èƒ½ã€‚

* * *

## äºŒã€æŠ€æœ¯å®ç°

ä¸ºæ”¯æ’‘â€œ**æ„ŸçŸ¥-å†³ç­–-æ‰§è¡Œ**â€é—­ç¯ï¼ŒåŸºäº Kotlin åç¨‹ä¸å“åº”å¼æ€æƒ³ï¼Œæ„å»ºäº†ä¸€å¥—è½»é‡çº§ã€çº¿ç¨‹å®‰å…¨çš„åœºæ™¯å¼•æ“å®ç°ã€‚æ•´ä½“æ¶æ„éµå¾ª **ä¿¡å·é©±åŠ¨ + è§„åˆ™åŒ¹é… + åŠ¨ä½œå›è°ƒ** ï¼Œæ ¸å¿ƒæ¨¡å—å¦‚ä¸‹ï¼š

### 1. æ ¸å¿ƒæ•°æ®æ¨¡å‹

-   `Signal`ï¼šä»£è¡¨ä¸Šä¸‹æ–‡ä¸­çš„ä¸€ä¸ªåŸå­çŠ¶æ€å˜åŒ–ï¼ˆå¦‚ `speed=90`ï¼‰ï¼Œç”± `SignalManager` ç»Ÿä¸€ç®¡ç†ã€‚

```
data class Signal(
    val key: String,
    val value: Any
)
```

-   `Condition`ï¼šå®šä¹‰è§¦å‘æ¡ä»¶ï¼Œé‡‡ç”¨å¯†å°ç±»ï¼ˆ`sealed interface`ï¼‰æ”¯æŒå¤šç§åˆ¤æ–­é€»è¾‘ï¼ˆç­‰äºã€å¤§äºã€åœ¨é›†åˆä¸­ç­‰ï¼‰ï¼Œå¹¶å†…å»º `durationMs` å­—æ®µä»¥æ”¯æŒâ€œæŒç»­æ»¡è¶³ N ç§’æ‰è§¦å‘â€çš„è¯­ä¹‰ã€‚

```
sealed interface Condition {
    val signalKey: String
    val durationMs: Long

    /**
* è§¦å‘æ¡ä»¶ï¼šç›¸ç­‰
* keyï¼šä¿¡å·é”®
* expectedï¼šæœŸæœ›çš„å€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class Equals(val key: String, val expected: Any, val duration: Long = 0L) : Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }

    /**
* è§¦å‘æ¡ä»¶ï¼šå¤§äº
* keyï¼šä¿¡å·é”®
* thresholdï¼šé˜ˆå€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class GreaterThan(val key: String, val threshold: Number, val duration: Long = 0L) :
        Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }

    /**
* è§¦å‘æ¡ä»¶ï¼šå°äº
* keyï¼šä¿¡å·é”®
* thresholdï¼šé˜ˆå€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class LessThan(val key: String, val threshold: Number, val duration: Long = 0L) :
        Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }


    /**
* è§¦å‘æ¡ä»¶ï¼šåŒ…å«
* keyï¼šä¿¡å·é”®
* valueï¼šåŒ…å«çš„å€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class Contains(val key: String, val value: Any, val duration: Long = 0L) : Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }

    /**
* è§¦å‘æ¡ä»¶ï¼šåœ¨èŒƒå›´å†…
* keyï¼šä¿¡å·é”®
* startï¼šå¼€å§‹å€¼
* endï¼šç»“æŸå€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class Between(
        val key: String,
        val start: Number,
        val end: Number,
        val duration: Long = 0L
    ) : Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }

    /***
* è§¦å‘æ¡ä»¶ï¼šåœ¨é›†åˆä¸­
* keyï¼šä¿¡å·é”®
* allowedValuesï¼šå…è®¸çš„å€¼
* durationï¼šæŒç»­æ—¶é—´ï¼Œå•ä½æ¯«ç§’
*/
data class InSet(val key: String, val allowedValues: Set<Any>, val duration: Long = 0L) :
        Condition {
        override val signalKey: String = key
        override val durationMs: Long = duration
    }

}
```

-   `Action`ï¼šæè¿°è¦æ‰§è¡Œçš„æ“ä½œï¼ˆå¦‚ `enable_eco_mode`ï¼‰ï¼Œæºå¸¦å‚æ•°å­—å…¸ï¼Œä¾¿äºå¤–éƒ¨ç³»ç»Ÿè§£ææ‰§è¡Œã€‚

> æ­¤å¤„å·²ç»é«˜åº¦ç®€åŒ–ï¼Œå®é™…é¡¹ç›®ä¸­è¯·æ ¹æ®äº§å“éœ€æ±‚è¿›è¡Œæ‰©å±•ã€‚

```
class Action(
    val name: String,
    val params: Map<String, Any> = emptyMap()
)
```

-   `Scene`ï¼šåœºæ™¯çš„æ ¸å¿ƒè½½ä½“ï¼ŒåŒ…å«è¿›å…¥/é€€å‡ºæ¡ä»¶åˆ—è¡¨ã€è¿›å…¥/é€€å‡ºåŠ¨ä½œåˆ—è¡¨ï¼Œä»¥åŠå¯è®¢é˜…çš„ `onEnter`/`onExit` å›è°ƒã€‚ä½¿ç”¨ `AtomicReference` ç®¡ç†ç›‘å¬å™¨åˆ—è¡¨ï¼Œä¿è¯çº¿ç¨‹å®‰å…¨ä¸‹çš„åŠ¨æ€æ‰©å±•èƒ½åŠ›ã€‚

```
typealias SceneAction = (List<Action>) -> Unit

data class Scene(
    val id: String,
    val name: String,
    val enterConditions: List<Condition>,
    val exitConditions: List<Condition>,
    val enterActions: List<Action>,
    val exitActions: List<Action>,
    private val _onEnterListeners: AtomicReference<List<SceneAction>>,
    private val _onExitListeners: AtomicReference<List<SceneAction>>
) {
    // å¯¹å¤–æš´éœ²çš„ onEnter / onExit
    val onEnter: SceneAction = { actions ->
_onEnterListeners.get().forEach {
it(actions)
        }
}

val onExit: SceneAction = { actions ->
 synchronized(_onExitListeners) {
_onExitListeners.get().forEach {
it(actions)
            }
}
}

 /**
* å¿½ç•¥è§¦å‘æ¡ä»¶ï¼Œç›´æ¥æ‰§è¡Œåœºæ™¯
*/
fun enter() {
        onEnter(enterActions)
    }

    /**
* å¿½ç•¥é€€å‡ºæ¡ä»¶ï¼Œç›´æ¥é€€å‡ºåœºæ™¯
*/
fun exit() {
        onExit(exitActions)
    }

    /**
* è®¢é˜…æ–°çš„è¿›å…¥/é€€å‡ºå›è°ƒ
*/
fun subscribe(onEnter: SceneAction, onExit: SceneAction) {
        _onEnterListeners.updateAndGet { list -> list + onEnter }
        _onExitListeners.updateAndGet { list -> list + onExit }
}

    companion object {
        fun create(
            id: String,
            name: String,
            enterConditions: List<Condition> = emptyList(),
            exitConditions: List<Condition> = emptyList(),
            enterActions: List<Action> = emptyList(),
            exitActions: List<Action> = emptyList(),
            onEnter: SceneAction = {} ,
            onExit: SceneAction = {}
): Scene {
            return Scene(
                id = id,
                name = name,
                enterConditions = enterConditions,
                exitConditions = exitConditions,
                enterActions = enterActions,
                exitActions = exitActions,
                _onEnterListeners = AtomicReference(listOf(onEnter)),
                _onExitListeners = AtomicReference(listOf(onExit))
            )
        }
    }
}
```




### 2. ä¿¡å·ä¸­æ¢ï¼š`SignalManager`

ä½œä¸ºå…¨å±€å•ä¾‹ï¼Œ`SignalManager` è´Ÿè´£ï¼š

-   ç»´æŠ¤å½“å‰æ‰€æœ‰ä¿¡å·çš„æœ€æ–°å€¼å¿«ç…§ï¼ˆ`currentSignals`ï¼‰ï¼›
-   æä¾› `updateSignal()` æ¥å£ä¾›`CarService`æˆ–ç³»ç»ŸæœåŠ¡æ¨é€çŠ¶æ€å˜æ›´ï¼›
-   æ”¯æŒå¤šè§‚å¯Ÿè€…è®¢é˜…ï¼ˆ`subscribe`ï¼‰ï¼Œå½“ä»»ä¸€ä¿¡å·æ›´æ–°æ—¶ï¼Œå¹¿æ’­ç»™æ‰€æœ‰ç›‘å¬è€…ã€‚

è®¾è®¡ä¸Šæ•°æ®æºä¸æ¶ˆè´¹é€»è¾‘çš„è§£è€¦ï¼Œä»»ä½•æ¨¡å—åªéœ€ç›‘å¬ä¿¡å·å˜åŒ–å³å¯å‚ä¸åœºæ™¯è¯„ä¼°ã€‚

```
 /**
* ä¿¡å·ç®¡ç†å™¨ï¼Œç”¨äºç®¡ç†æ‰€æœ‰ä¿¡å·çš„å˜åŒ–å’Œè®¢é˜…
* è½¦è½½åº”ç”¨ä¸­ï¼Œä¼šå¯¹æ¥CarServiceå’Œå…¶ä»–ä¼ æ„Ÿå™¨ï¼Œå¹¶åœ¨åº”ç”¨å¯åŠ¨åç«‹å³å°†æ‰€æœ‰ä¿¡å·æ›´æ–°åˆ°ä¿¡å·ç®¡ç†å™¨ä¸­
*/
object SignalManager {
    private val currentSignals = mutableMapOf<String, Any>()
    private val listeners = mutableListOf<SignalListener>()

    /**
* æ›´æ–°ä¿¡å·å€¼ï¼Œå¹¶é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
*/
fun updateSignal(signal: Signal) {
        println("[updateSignal]: $signal")
        currentSignals[signal.key] = signal.value
        listeners.forEach { it(signal) }
}

    /**
* è·å–å½“å‰ä¿¡å·å€¼
* @param key ä¿¡å·é”®å€¼
* @return å½“å‰ä¿¡å·å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›null
*/
fun getCurrentValue(key: String): Any? = currentSignals[key]

    /**
* è®¢é˜…ä¿¡å·å˜åŒ–ï¼Œå¹¶æ³¨å†Œç›‘å¬å™¨
*/
fun subscribe(listener: (Signal) -> Unit) {
        listeners.add(listener)
    }

    /**
* å–æ¶ˆè®¢é˜…ï¼Œç§»é™¤ç›‘å¬å™¨
*/
fun unsubscribe(listener: (Signal) -> Unit) {
        listeners.remove(listener)
    }
}
```




### 3. è§„åˆ™å¼•æ“ï¼š`RuleEngine`

`RuleEngine` æ˜¯æ•´ä¸ªç³»ç»Ÿçš„è°ƒåº¦æ ¸å¿ƒï¼Œå…¶å…³é”®è®¾è®¡åŒ…æ‹¬ï¼š

-   åå‘ç´¢å¼•ä¼˜åŒ–ï¼šæ„å»º `signalKey â†’ [sceneId]` çš„æ˜ å°„ï¼ˆåˆ†ä¸ºè¿›å…¥/é€€å‡ºä¸¤å¥—ï¼‰ï¼Œä½¿å¾—æ¯æ¬¡ä¿¡å·æ›´æ–°ä»…éœ€è¯„ä¼°å¯èƒ½å—å½±å“çš„åœºæ™¯ï¼Œé¿å…å…¨é‡æ‰«æï¼Œæ˜¾è‘—æå‡æ€§èƒ½ã€‚
-   çŠ¶æ€æŒä¹…åŒ–ï¼šä½¿ç”¨ `enterStates` / `exitStates` è®°å½•æ¯ä¸ªæ¡ä»¶çš„é¦–æ¬¡æ»¡è¶³æ—¶é—´æˆ³ï¼Œç”¨äºè®¡ç®—æ˜¯å¦è¾¾åˆ° `duration` è¦æ±‚ã€‚
-   åç¨‹è°ƒåº¦ï¼šåˆ©ç”¨ `kotlinx.coroutines` å®ç°å»¶è¿Ÿé‡è¯„ã€‚å½“æ¡ä»¶æ»¡è¶³ä½†æœªè¾¾æŒç»­æ—¶é—´æ—¶ï¼Œè‡ªåŠ¨è°ƒåº¦ä¸€ä¸ªå»¶è¿Ÿä»»åŠ¡ï¼Œåœ¨ç²¾ç¡®æ—¶åˆ»é‡æ–°è¯„ä¼°ï¼Œé¿å…è½®è¯¢å¼€é”€ã€‚
-   åºåˆ—è¿½è¸ªï¼šé€šè¿‡ `sequenceProgress` å’Œ `lastStepTimestamp` ä¸¤ä¸ªå¹¶å‘å®‰å…¨çš„ Mapï¼Œè®°å½•æ¯ä¸ªåœºæ™¯åœ¨åºåˆ—åŒ¹é…ä¸­çš„å½“å‰è¿›åº¦ä¸ä¸Šä¸€æ­¥å®Œæˆæ—¶é—´ï¼Œç¡®ä¿æ—¶åºé€»è¾‘æ­£ç¡®ã€‚

ä»£ç å¤ªé•¿ï¼Œå®Œæ•´ä»£ç è¯·å‚è€ƒï¼šhttps://github.com/linxu-link/VehicleSceneEngine/blob/master/app/src/main/java/com/wj/sceneengine/engine/RuleEngine.kt

* * *

## ä¸‰ã€è¿›é˜¶éœ€æ±‚åˆ†æ

åœ¨åŸºç¡€è§„åˆ™åŒ¹é…ä¹‹ä¸Šï¼ŒçœŸå®è½¦è½½åœºæ™¯å¸¸æ¶‰åŠæ›´å¤æ‚çš„æ—¶ç©ºé€»è¾‘ã€‚å¼•æ“é€šè¿‡ä¸¤ç§æœºåˆ¶åº”å¯¹å…¸å‹è¿›é˜¶éœ€æ±‚ï¼š

1.  ### æŒç»­æ»¡è¶³ N ç§’æ‰è§¦å‘

éœ€æ±‚èƒŒæ™¯ï¼šç¬æ—¶ä¿¡å·æ³¢åŠ¨ï¼ˆå¦‚é›·è¾¾è¯¯æŠ¥ã€GPSè·³å˜ï¼‰ä¸åº”å¯¼è‡´åœºæ™¯é¢‘ç¹åˆ‡æ¢ã€‚ å®ç°æ–¹æ¡ˆï¼š

-   åœ¨ `Condition` ä¸­å¢åŠ  `durationMs` å­—æ®µã€‚
-   `RuleEngine` åœ¨é¦–æ¬¡æ»¡è¶³æ¡ä»¶æ—¶è®°å½•æ—¶é—´æˆ³ï¼Œåç»­æ¯æ¬¡è¯„ä¼°æ£€æŸ¥ `(now - startTime) >= durationMs`ã€‚
-   è‹¥æ¡ä»¶ä¸­é€”ä¸æ»¡è¶³ï¼Œåˆ™ç«‹å³æ¸…é™¤è®¡æ—¶çŠ¶æ€ã€‚
-   åˆ©ç”¨åç¨‹ `delay()` ç²¾ç¡®è°ƒåº¦é‡è¯„ä»»åŠ¡ï¼Œè€Œéä½æ•ˆè½®è¯¢ã€‚

```
// æ¡ä»¶çŠ¶æ€è®°å½•
private val enterStates = ConcurrentHashMap<String, MutableMap<Condition, Long>>()
private val exitStates = ConcurrentHashMap<String, MutableMap<Condition, Long>>()
// åç¨‹ä¸ä»»åŠ¡ç®¡ç†
private val enterJobs = ConcurrentHashMap<String, Job>()
private val exitJobs = ConcurrentHashMap<String, Job>()
private val mutex = Mutex()
private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

private fun processEnterLogic(scene: Scene, now: Long, triggerSignal: Signal?) {
    val enterState = enterStates.getOrPut(scene.id) { ConcurrentHashMap() }

// 1. å¤„ç†åºåˆ—æ¡ä»¶ (å¦‚æœæœ‰)
    val seqCond = scene.enterConditions.filterIsInstance<SequenceCondition>().firstOrNull()
    val seqSatisfied = if (seqCond != null) {
        updateAndCheckSequence(scene.id, seqCond, triggerSignal, now)
    } else true

    // 2. å¤„ç†æ™®é€šæ¡ä»¶ (Duration é€»è¾‘)
    val normalConds = scene.enterConditions.filter { it !is SequenceCondition }
var allNormalSatisfied = true

    normalConds.forEach { cond ->
if (evaluateCondition(cond)) {
            enterState.putIfAbsent(cond, now) // è®°å½•é¦–æ¬¡æ»¡è¶³çš„æ—¶é—´æˆ³
        } else {
            enterState.remove(cond) // ä¸€æ—¦ä¸æ»¡è¶³ç«‹å³æ¸…é™¤è®¡æ—¶
            allNormalSatisfied = false
        }
    }

// 3. ç»¼åˆåˆ¤å®š
    if (allNormalSatisfied && seqSatisfied && scene.enterConditions.isNotEmpty()) {
        val allDurationMet = normalConds.all { cond ->
val startTime = enterState[cond] ?: now
            (now - startTime) >= cond.durationMs
        }

if (allDurationMet) {
            enterJobs[scene.id]?.cancel()
            scene.enter()
        } else {
            // è®¡ç®—è¿˜éœ€è¦ç­‰å¾…å¤šä¹…
            val remainingWait = normalConds.maxOf { cond ->
val elapsed = now - (enterState[cond] ?: now)
                (cond.durationMs - elapsed).coerceAtLeast(0L)
            }
scheduleReEvaluation(scene, remainingWait, true)
        }
    } else {
        enterJobs[scene.id]?.cancel()
    }
}
```




### 2. æ—¶åºæ•æ„Ÿå‹åœºæ™¯

éœ€æ±‚èƒŒæ™¯ï¼šæŸäº›åœºæ™¯çš„è§¦å‘éœ€ä¸¥æ ¼æŒ‰é¡ºåºæ‰§è¡Œï¼ˆå¦‚â€œè¸©åˆ¹è½¦ â†’ æŒ‰å¯åŠ¨é”®â€ï¼‰ã€‚ å®ç°æ–¹æ¡ˆï¼š

-   å¼•å…¥ `SequenceCondition`ï¼Œå°†å¤šæ­¥æ“ä½œå°è£…ä¸ºä¸€ä¸ªå¤åˆæ¡ä»¶ã€‚

-   å¼•æ“å†…éƒ¨ç»´æŠ¤æ¯ä¸ªåœºæ™¯çš„åºåˆ—è¿›åº¦ï¼ˆ`sequenceProgress`ï¼‰å’Œæ­¥éª¤é—´çš„æ—¶é—´çª—å£ï¼ˆ`timeoutMs`ï¼‰ã€‚

-   æ¯æ¬¡ä¿¡å·æ›´æ–°æ—¶ï¼š

    -   æ£€æŸ¥å‰ç½®æ­¥éª¤æ˜¯å¦ä»æœ‰æ•ˆï¼ˆé˜²æ­¢çŠ¶æ€å›é€€å¯¼è‡´é€»è¾‘é”™è¯¯ï¼‰ï¼›
    -   è‹¥å½“å‰ä¿¡å·åŒ¹é…ä¸‹ä¸€æ­¥æ¡ä»¶ä¸”æœªè¶…æ—¶ï¼Œåˆ™æ¨è¿›è¿›åº¦ï¼›
    -   è‹¥åºåˆ—å®Œæ•´åŒ¹é…ï¼Œåˆ™è§†ä¸ºæ¡ä»¶æ»¡è¶³ã€‚


```
data class SequenceCondition(
    val steps: List<SequenceStep>
) : Condition {
    override val signalKey: String = steps.firstOrNull()?.condition?.signalKey ?: ""
    override val durationMs: Long = 0L
}

// åºåˆ—è¿›åº¦è¿½è¸ªï¼šsceneId -> å½“å‰åŒ¹é…åˆ°çš„æ­¥éª¤ç´¢å¼•
private val sequenceProgress = ConcurrentHashMap<String, Int>()
private val lastStepTimestamp = ConcurrentHashMap<String, Long>()

private fun updateAndCheckSequence(sceneId: String, seq: SequenceCondition, signal: Signal?, now: Long): Boolean {
    val currentIndex = sequenceProgress.getOrDefault(sceneId, 0)
    if (currentIndex == 0 && signal == null) return false

    // è·å–å½“å‰æ­£åœ¨ç­‰å¾…åŒ¹é…çš„æ­¥éª¤
    val currentStep = seq.steps[currentIndex]

    // ç­–ç•¥ï¼šæ£€æŸ¥å·²ç»åŒ¹é…æˆåŠŸçš„é‚£äº›æ­¥éª¤æ˜¯å¦ä¾ç„¶æœ‰æ•ˆ
    // å¦‚æœåºåˆ—è¦æ±‚ A -> Bï¼Œå½“å‰åœ¨ç­‰ Bï¼Œä½† A çªç„¶ä¸æ»¡è¶³äº†ï¼Œåºåˆ—åº”é‡ç½®
    for (i in 0 until currentIndex) {
        if (!evaluateCondition(seq.steps[i].condition)) {
            sequenceProgress[sceneId] = 0 // å‰ç½®æ­¥éª¤å¤±æ•ˆï¼Œé‡ç½®
            return false
        }
    }

    // æ£€æŸ¥æ­¥éª¤é—´æ˜¯å¦è¶…æ—¶
    val lastTime = lastStepTimestamp.getOrDefault(sceneId, 0L)
    if (currentIndex > 0 && (now - lastTime) > currentStep.timeoutMs) {
        sequenceProgress[sceneId] = 0
        return false
    }

    // å¤„ç†å½“å‰ä¿¡å·è§¦å‘çš„è¿›åº¦æ¨è¿›
    if (signal != null && signal.key == currentStep.condition.signalKey) {
        if (evaluateCondition(currentStep.condition)) {
            val nextIndex = currentIndex + 1
            if (nextIndex >= seq.steps.size) {
                return true // åºåˆ—å…¨åŒ¹é…
            } else {
                sequenceProgress[sceneId] = nextIndex
                lastStepTimestamp[sceneId] = now
            }
        } else if (currentIndex > 0) {
            // å¦‚æœæ˜¯å½“å‰æ­¥éª¤çš„ä¿¡å·å‘ç”Ÿäº†å˜åŒ–ä¸”å˜å¾—ä¸æ»¡è¶³ï¼Œé‡ç½®
            sequenceProgress[sceneId] = 0
        }
    }
    return false
}
```  


## å››ã€ä½¿ç”¨æ–¹å¼

### 1. æ»¡è¶³æ¡ä»¶å³å¯è‡ªåŠ¨è§¦å‘çš„åœºæ™¯

è§„åˆ™ï¼šè½¦è¾†ç”µé‡ä½äº 20% æ—¶ï¼Œè‡ªåŠ¨è§¦å‘ ECO æ¨¡å¼ï¼Œç”µé‡é«˜äº60ï¼… æ—¶ï¼Œè‡ªåŠ¨é€€å‡º ECO æ¨¡å¼

```
// 1. è‡ªåŠ¨è§¦å‘ECOæ¨¡å¼
// è§„åˆ™ï¼šè½¦è¾†ç”µé‡ä½äº 20% æ—¶ï¼Œè‡ªåŠ¨è§¦å‘ ECO æ¨¡å¼ï¼Œç”µé‡é«˜äº60ï¼… æ—¶ï¼Œè‡ªåŠ¨é€€å‡º ECO æ¨¡å¼
val ecoScene = Scene.create(
    id = "eco_mode",
    name = "ECO æ¨¡å¼",
    enterActions = listOf(Action("enable_eco_mode", mapOf("mode" to "eco"))),
    exitActions = listOf(Action("disable_eco_mode", mapOf("mode" to "eco"))),
    enterConditions = listOf(
        Condition.LessThan("battery_level", 20)
    ),
    exitConditions = listOf(
        Condition.GreaterThan("battery_level", 60)
    ),
    onEnter = { actions ->
 println("ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å·²è¿›å…¥ ECO æ¨¡å¼ï¼šå¼€å¯èŠ‚èƒ½æ¨¡å¼\n")
        // è§£æ actions æ‰§è¡Œå…¶ä»–æ“ä½œ
    } ,
    onExit = { actions ->
 println("ğŸ”´ [åœºæ™¯é€€å‡º] å·²é€€å‡º ECO æ¨¡å¼ï¼šå…³é—­èŠ‚èƒ½æ¨¡å¼\n")
    } ,
)
engine.addScene(ecoScene)

// --- æµ‹è¯• 1: åºåˆ—äº‹ä»¶éªŒè¯ ---
println("--- æµ‹è¯• 1: æµ‹è¯•åœºæ™¯å¼•æ“ï¼ˆè‡ªåŠ¨è§¦å‘ECOæ¨¡å¼ï¼‰ ---")
SignalManager.updateSignal(Signal("battery_level", 10))
delay(1000)
SignalManager.updateSignal(Signal("battery_level", 30))
delay(1000)
SignalManager.updateSignal(Signal("battery_level", 50))
delay(1000)
SignalManager.updateSignal(Signal("battery_level", 70))
```




æ‰§è¡Œç»“æœï¼š

-   å½“å¼•æ“æ¥æ”¶åˆ°ç”µé‡=10æ—¶ï¼Œè‡ªåŠ¨è§¦å‘ã€Ecoæ¨¡å¼ã€‘
-   å½“å¼•æ“æ¥æ”¶åˆ°ç”µé‡=70æ—¶ï¼Œè‡ªåŠ¨é€€å‡ºã€Ecoæ¨¡å¼ã€‘

```
--- æµ‹è¯• 1: æµ‹è¯•åœºæ™¯å¼•æ“ï¼ˆè‡ªåŠ¨è§¦å‘ECOæ¨¡å¼ï¼‰ ---
[updateSignal]: Signal(key=battery_level, value=10)
ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å·²è¿›å…¥ ECO æ¨¡å¼ï¼šå¼€å¯èŠ‚èƒ½æ¨¡å¼

[updateSignal]: Signal(key=battery_level, value=30)
[updateSignal]: Signal(key=battery_level, value=50)
[updateSignal]: Signal(key=battery_level, value=70)
ğŸ”´ [åœºæ™¯é€€å‡º] å·²é€€å‡º ECO æ¨¡å¼ï¼šå…³é—­èŠ‚èƒ½æ¨¡å¼
```




### 2. æŒç»­æ»¡è¶³è§„å®šçš„æ—¶é—´æ‰å¯è§¦å‘çš„åœºæ™¯

è§„åˆ™ï¼šè½¦é€Ÿå¿…é¡»å¤§äº 80 km/hï¼Œä¸”æŒç»­ 5 ç§’æ‰èƒ½è§¦å‘ï¼ˆé˜²æ­¢å› ç¬é—´åŠ é€Ÿè¯¯è§¦å‘ï¼‰ã€‚

```
// 2. å®šä¹‰å¸¦æŒç»­æ—¶é—´çš„åœºæ™¯ï¼šé«˜é€Ÿå·¡èˆªæ¨¡å¼
// è§„åˆ™ï¼šè½¦é€Ÿå¿…é¡»å¤§äº 80 km/hï¼Œä¸”æŒç»­ 5 ç§’ï¼Œé˜²æ­¢å› ç¬é—´åŠ é€Ÿè¯¯è§¦å‘
val highSpeedScene = Scene.create(
    id = "high_speed_cruise",
    name = "é«˜é€Ÿå·¡èˆªæ¨¡å¼",
    enterConditions = listOf(
        Condition.GreaterThan("speed", 80, duration = 5000) // å¿…é¡»æŒç»­ 5s
    ),
    exitConditions = listOf(
        Condition.LessThan("speed", 70) // é€€å‡ºåˆ™ä¸éœ€è¦æŒç»­æ—¶é—´
    ),
    onEnter = { actions ->
 println("ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å·²è¿›å…¥é«˜é€Ÿå·¡èˆªæ¨¡å¼ï¼šå±•å¼€å°¾ç¿¼\n")
        // è§£æ actions æ‰§è¡Œå…¶ä»–æ“ä½œï¼Œå¦‚è°ƒæ•´å‘åŠ¨æœºæ€§èƒ½
    } ,
    onExit = { actions ->
 println("ğŸ”´ [åœºæ™¯é€€å‡º] é€€å‡ºé«˜é€Ÿå·¡èˆªæ¨¡å¼ï¼šå…³é—­å°¾ç¿¼\n")
    }
)
engine.addScene(highSpeedScene)

// --- æµ‹è¯• 2: æŒç»­æ—¶é—´éªŒè¯ ---
println("--- æµ‹è¯• 2: å¼€å§‹æŒç»­æ—¶é—´éªŒè¯ (Speed > 80 for 5s) ---")
SignalManager.updateSignal(Signal("speed", 100))
println("å½“å‰è½¦é€Ÿ 100ï¼Œç­‰å¾…å¼•æ“è®¡æ—¶...")
// æ¨¡æ‹Ÿ 3 ç§’åæŸ¥çœ‹çŠ¶æ€ï¼ˆæ­¤æ—¶ä¸åº”æ¿€æ´»ï¼Œå› ä¸ºæœªæ»¡ 5sï¼‰
delay(3000)
println("è®¡æ—¶ 3s æ—¶ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: ${engine.isSceneActive(highSpeedScene.id)}")
// å†ç­‰ 3 ç§’ï¼ˆæ€»è®¡ 6sï¼‰ï¼Œåº”è¯¥æ¿€æ´»
delay(3000)
println("è®¡æ—¶ 6s æ—¶ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: ${engine.isSceneActive(highSpeedScene.id)}")
SignalManager.updateSignal(Signal("speed", 67))
delay(1000)

// --- æµ‹è¯• 3: ä¿¡å·æŠ–åŠ¨æ‹¦æˆª ---
println("--- æµ‹è¯• 3: æµ‹è¯•ä¿¡å·æŠ–åŠ¨æ˜¯å¦ä¼šé‡ç½®è®¡æ—¶ ---")
SignalManager.updateSignal(Signal("speed", 60)) // å…ˆé™é€Ÿ
delay(500)
SignalManager.updateSignal(Signal("speed", 120)) // é‡æ–°æé€Ÿ
delay(3000)
SignalManager.updateSignal(Signal("speed", 50)) // åœ¨ 5s åˆ°è¾¾å‰çªç„¶é™é€Ÿ
delay(3000)
println(
    "ä¿¡å·æŠ–åŠ¨åï¼ˆæœªæ»¡5så³ä¸­æ–­ï¼‰ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: ${
        engine.isSceneActive(
            highSpeedScene.id
        )
    }"
)
```

æ‰§è¡Œç»“æœï¼š

-   è½¦é€Ÿ=100æ—¶ï¼Œã€é«˜é€Ÿå·¡èˆªæ¨¡å¼ã€‘æ²¡æœ‰ç«‹å³æ¿€æ´»
-   æŒç»­5såï¼Œè‡ªåŠ¨è§¦å‘ã€é«˜é€Ÿå·¡èˆªæ¨¡å¼ã€‘
-   è½¦é€Ÿ=67æ—¶ï¼Œè‡ªåŠ¨é€€å‡ºã€é«˜é€Ÿå·¡èˆªæ¨¡å¼ã€‘
-   å½“è½¦é€Ÿå…ˆé€’å¢è‡³120ï¼Œå†ä¸‹é™è‡³50ï¼Œä¸ä¼šè§¦å‘ã€é«˜é€Ÿå·¡èˆªæ¨¡å¼ã€‘

```
--- æµ‹è¯• 2: å¼€å§‹æŒç»­æ—¶é—´éªŒè¯ (Speed > 80 for 5s) ---
[updateSignal]: Signal(key=speed, value=100)
å½“å‰è½¦é€Ÿ 100ï¼Œç­‰å¾…å¼•æ“è®¡æ—¶...
è®¡æ—¶ 3s æ—¶ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: false
ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å·²è¿›å…¥é«˜é€Ÿå·¡èˆªæ¨¡å¼ï¼šå±•å¼€å°¾ç¿¼

è®¡æ—¶ 6s æ—¶ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: true
[updateSignal]: Signal(key=speed, value=67)
ğŸ”´ [åœºæ™¯é€€å‡º] é€€å‡ºé«˜é€Ÿå·¡èˆªæ¨¡å¼ï¼šå…³é—­å°¾ç¿¼

--- æµ‹è¯• 3: æµ‹è¯•ä¿¡å·æŠ–åŠ¨æ˜¯å¦ä¼šé‡ç½®è®¡æ—¶ ---
[updateSignal]: Signal(key=speed, value=60)
[updateSignal]: Signal(key=speed, value=120)
[updateSignal]: Signal(key=speed, value=50)
ä¿¡å·æŠ–åŠ¨åï¼ˆæœªæ»¡5så³ä¸­æ–­ï¼‰ï¼Œé«˜é€Ÿå·¡èˆªåœºæ™¯æ˜¯å¦æ¿€æ´»: false
```




### 3. æ»¡è¶³è§„å®šçš„åºåˆ—æ‰å¯è§¦å‘çš„åœºæ™¯

è§„åˆ™ï¼šå¿…é¡»å…ˆâ€œè¸©ä¸‹åˆ¹è½¦â€ï¼Œç„¶ååœ¨ 3 ç§’å†…â€œæŒ‰ä¸‹å¯åŠ¨é”®â€ï¼Œæ‰èƒ½æ¿€æ´»â€œåŠ¨åŠ›ç³»ç»Ÿâ€ã€‚

```
// 3. å¸¦åºåˆ—çš„å®‰å…¨å¯åŠ¨æ ¡éªŒåœºæ™¯
// è§„åˆ™ï¼šå¿…é¡»å…ˆâ€œè¸©ä¸‹åˆ¹è½¦â€ï¼Œç„¶ååœ¨ 3 ç§’å†…â€œæŒ‰ä¸‹å¯åŠ¨é”®â€ï¼Œæ‰èƒ½æ¿€æ´»â€œåŠ¨åŠ›ç³»ç»Ÿâ€
val securitySequenceScene = Scene.create(
    id = "security_start",
    name = "å®‰å…¨å¯åŠ¨æ¨¡å¼",
    enterConditions = listOf(
        SequenceCondition(
            steps = listOf(
                SequenceStep(
                    Condition.Equals("brake_pedal", "pressed"), timeoutMs = 0
                ),
                SequenceStep(
                    Condition.Equals("start_button", "clicked"), timeoutMs = 3000
                )
            )
        )
    ),
    enterActions = listOf(Action("enable_motor", mapOf("power" to 100))),
    onEnter = { println("ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å®‰å…¨æ ¡éªŒé€šè¿‡ï¼šåŠ¨åŠ›ç³»ç»Ÿå·²å°±ç»ªï¼\n") }
)
engine.addScene(securitySequenceScene)

// --- æµ‹è¯• 4: åºåˆ—äº‹ä»¶éªŒè¯ ---
println("--- æµ‹è¯• 4: å¼€å§‹å®‰å…¨å¯åŠ¨åºåˆ—æµ‹è¯• ---")
println("å…ˆè¸©ä¸‹åˆ¶åŠ¨è¸æ¿")
SignalManager.updateSignal(Signal("brake_pedal", "pressed"))
delay(1000)
println("æ¾å¼€åˆ¶åŠ¨è¸æ¿")
SignalManager.updateSignal(Signal("brake_pedal", "unpressed"))
delay(1000)
println("ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®")
SignalManager.updateSignal(Signal("start_button", "clicked"))
println("å®‰å…¨å¯åŠ¨åœºæ™¯æ˜¯å¦æ¿€æ´»: ${engine.isSceneActive(securitySequenceScene.id)}")
delay(1000)
println("å†æ¬¡åˆ¶åŠ¨è¸æ¿")
SignalManager.updateSignal(Signal("brake_pedal", "pressed"))
delay(2000)
println("ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®")
SignalManager.updateSignal(Signal("start_button", "clicked"))
delay(1000)
println(" ============= æµ‹è¯•åœºæ™¯å¼•æ“ end ============")
```

æ‰§è¡Œç»“æœï¼š

-   å…ˆè¸©ä¸‹åˆ¶åŠ¨è¸æ¿ï¼Œç´§æ¥ç€æ¾å¼€åˆ¶åŠ¨è¸æ¿
-   ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®ï¼Œã€å®‰å…¨å¯åŠ¨æ¨¡å¼ã€‘æœªæ¿€æ´»
-   å†æ¬¡è¸©ä¸‹åˆ¶åŠ¨è¸æ¿
-   ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®ï¼Œè‡ªåŠ¨è¿›å…¥ã€å®‰å…¨å¯åŠ¨æ¨¡å¼ã€‘

```
--- æµ‹è¯• 4: å¼€å§‹å®‰å…¨å¯åŠ¨åºåˆ—æµ‹è¯• ---
å…ˆè¸©ä¸‹åˆ¶åŠ¨è¸æ¿
[updateSignal]: Signal(key=brake_pedal, value=pressed)
æ¾å¼€åˆ¶åŠ¨è¸æ¿
[updateSignal]: Signal(key=brake_pedal, value=unpressed)
ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®
[updateSignal]: Signal(key=start_button, value=clicked)
å®‰å…¨å¯åŠ¨åœºæ™¯æ˜¯å¦æ¿€æ´»: false
å†æ¬¡åˆ¶åŠ¨è¸æ¿
[updateSignal]: Signal(key=brake_pedal, value=pressed)
ç­‰å¾… 1 ç§’åæŒ‰ä¸‹å¯åŠ¨é”®
[updateSignal]: Signal(key=start_button, value=clicked)
ğŸŸ¢ [åœºæ™¯æ¿€æ´»] å®‰å…¨æ ¡éªŒé€šè¿‡ï¼šåŠ¨åŠ›ç³»ç»Ÿå·²å°±ç»ªï¼
```




## äº”ã€æ€»ç»“

å›é¡¾ä¸€ä¸‹ï¼Œâ€œåœºæ™¯å¼•æ“â€è¿™ä¸ªæ¦‚å¿µå¬èµ·æ¥é¢‡ä¸ºé«˜ç«¯ï¼Œä½†æ‹†å¼€æ¥çœ‹ï¼Œå®ƒçš„æ ¸å¿ƒå…¶å®å°±æ˜¯ä¸€ä¸ªè§„åˆ™å¼•æ“ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å½“å‰çš„å®ç°ä»…ä»…æ˜¯ä¸€ä¸ªå¼€ç«¯ï¼Œéšç€å¤§æ¨¡å‹çš„é›†æˆå’Œç”¨æˆ·è¡Œä¸ºæ•°æ®çš„æŒç»­ç§¯ç´¯ï¼Œåœºæ™¯å¼•æ“æœ‰æœ›ä»è¢«åŠ¨å“åº”è§„åˆ™æ¼”è¿›åˆ°ä¸»åŠ¨é¢„æµ‹ç”¨æˆ·æ„å›¾ã€‚å¸Œæœ›è¿™ç¯‡åˆ†äº«èƒ½ä¸ºä½ æä¾›ä¸€äº›çµæ„Ÿå’Œæ€è€ƒã€‚

æœ¬æ–‡æºç ï¼šhttps://github.com/linxu-link/VehicleSceneEngine
